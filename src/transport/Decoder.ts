import {Const} from "transport/Const";
import {DecodeBuffer} from "transport/DecodeBuffer";
import {DecodeDataPool} from "transport/DecodeDataPool";
import {DecodeMetaPool, Struct} from "transport/DecodeMetaPool";

/**
 * Decoder wraps smartbuf's decoder implementation, it accepts and maintains schema info generated by Encoder.
 *
 * @author sulin
 * @since 2019-11-25 21:04:45
 */
export class Decoder {
    private readonly enableStreamMode: boolean;

    private sequence: number;
    private dataPool = new DecodeDataPool();
    private metaPool = new DecodeMetaPool();

    /**
     * Initialize decoder
     *
     * @param enableStreamMode If enable stream-mode, if not, enable packet-mode
     */
    constructor(enableStreamMode: boolean) {
        this.enableStreamMode = enableStreamMode;
    }

    public read(data: Uint8Array): any {
        let buffer = new DecodeBuffer(data);

        this.dataPool.reset();
        this.metaPool.reset();

        let head = buffer.readByte();
        let stream = (head & Const.VER_STREAM) != 0;
        let hasMeta = (head & Const.VER_HAS_META) != 0;
        let hasData = (head & Const.VER_HAS_DATA) != 0;
        let hasSeq = (head & Const.VER_HAS_SEQ) != 0;
        // valid schema
        if ((head & 0b1111_0000) != Const.VER) {
            // throw new InvalidVersionException(Const.VER, head & 0b1111_0000);
            throw new Error("");
        }
        if (stream != this.enableStreamMode) {
            // throw new MismatchModeException(stream);
            throw new Error("");
        }
        // only stream-mode needs sequence
        if (hasSeq) {
            let nextSeq = this.sequence + 1;
            let recvSeq = buffer.readByte() & 0xFF;
            if (recvSeq != (nextSeq & 0xFF)) {
                // throw new UnexpectedSequenceException(nextSeq & 0xFF, recvSeq);
                throw new Error("");
            }
            this.sequence = nextSeq;
        }
        // read temporary metadata
        if (hasMeta) {
            this.metaPool.read(buffer);
        }
        // read context metadata
        if (hasData) {
            this.dataPool.read(buffer);
        }
        // load data
        return this.readData(buffer);
    }

    /**
     * Read the next any data, it could be normal data, array, object.
     */
    private readData(buffer: DecodeBuffer): any {
        let head = buffer.readVarUint();
        switch (head) {
            case Const.CONST_NULL:
                return null;
            case Const.CONST_TRUE:
                return true;
            case Const.CONST_FALSE:
                return false;
            case Const.CONST_ZERO_ARRAY:
                return [];
        }
        let flag = (head & 0b0000_0111);
        switch (flag) {
            case Const.TYPE_VARINT:
                return this.dataPool.getVarint(head >>> 3);
            case Const.TYPE_FLOAT:
                return this.dataPool.getFloat(head >>> 3);
            case Const.TYPE_DOUBLE:
                return this.dataPool.getDouble(head >>> 3);
            case Const.TYPE_STRING:
                return this.dataPool.getString(head >>> 3);
            case Const.TYPE_SYMBOL:
                return this.dataPool.getSymbol(head >>> 3);
            case Const.TYPE_NARRAY:
                return this.readNativeArray(buffer, head);
            case Const.TYPE_ARRAY:
                return this.readArray(buffer, head >>> 3);
            default:
                let struct = this.metaPool.findStructByID(head >>> 3);
                return this.readObject(buffer, struct);
        }
    }

    /**
     * Read an native array, like byte[] int[]
     */
    private readNativeArray(buffer: DecodeBuffer, head: number): any {
        let type = (head & 0b0011_1111);
        let size = (head >>> 6);
        switch (type) {
            case Const.TYPE_NARRAY_BOOL:
                return buffer.readBooleanArray(size);
            case Const.TYPE_NARRAY_BYTE:
                return buffer.readByteArray(size);
            case Const.TYPE_NARRAY_SHORT:
                return buffer.readShortArray(size);
            case Const.TYPE_NARRAY_INT:
                return buffer.readIntArray(size);
            case Const.TYPE_NARRAY_LONG:
                return buffer.readLongArray(size);
            case Const.TYPE_NARRAY_FLOAT:
                return buffer.readFloatArray(size);
            case Const.TYPE_NARRAY_DOUBLE:
                return buffer.readDoubleArray(size);
            default:
                throw new Error("unknown narray type");
        }
    }

    /**
     * Read an array by the specified head info
     */
    private readArray(buffer: DecodeBuffer, head: number): any {
        let slices = new Array<Array<any>>();
        let totalSize = 0;
        while (true) {
            let type = (head >>> 1) & 0x0F;
            let size = (head >>> 5);
            totalSize += size;
            let slice = new Array<any>(size);
            switch (type) {
                case Const.TYPE_SLICE_NULL:
                    break;
                case Const.TYPE_SLICE_BOOL:
                    for (let i = 0; i < size; i++) {
                        let b = buffer.readByte();
                        switch (b) {
                            case Const.CONST_TRUE:
                                slice[i] = true;
                                break;
                            case Const.CONST_FALSE:
                                slice[i] = false;
                                break;
                            default:
                                throw new Error("invalid bool[" + b + "] at offset " + i);
                        }
                    }
                    break;
                case Const.TYPE_SLICE_BYTE:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readByte();
                    }
                    break;
                case Const.TYPE_SLICE_SHORT:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_INT:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_LONG:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_FLOAT:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readFloat();
                    }
                    break;
                case Const.TYPE_SLICE_DOUBLE:
                    for (let i = 0; i < size; i++) {
                        slice[i] = buffer.readDouble();
                    }
                    break;
                case Const.TYPE_SLICE_SYMBOL:
                    slice = new String[size];
                    for (let i = 0; i < size; i++) {
                        let dataId = buffer.readVarUint();
                        slice[i] = this.enableStreamMode ? this.dataPool.getSymbol(dataId) : this.dataPool.getString(dataId);
                    }
                    break;
                case Const.TYPE_SLICE_STRING:
                    slice = new Object[size];
                    for (let i = 0; i < size; i++) {
                        slice[i] = this.dataPool.getString(buffer.readVarUint());
                    }
                    break;
                case Const.TYPE_SLICE_OBJECT:
                    slice = new Object[size];
                    let structId = buffer.readVarUint();
                    let struct = this.metaPool.findStructByID(structId);
                    for (let i = 0; i < size; i++) {
                        slice[i] = this.readObject(buffer, struct);
                    }
                    break;
                case Const.TYPE_SLICE_UNKNOWN:
                    slice = new Object[size];
                    for (let i = 0; i < size; i++) {
                        slice[i] = this.readData(buffer);
                    }
                    break;
                default:
                    throw new Error("run into invalid slice type: " + type);
            }
            slices.push(slice);
            if ((head & 1) == 0) {
                break;
            }
            head = buffer.readShort() & 0xFFFF;
        }
        if (slices.length == 1) {
            return slices[0];
        }
        let result = new Array<any>(totalSize);
        let off = 0;
        for (let slice of slices) {
            for (let o of slice) {
                result[off++] = o;
            }
        }
        return result;
    }

    /**
     * Read an object by the specified fields
     */
    private readObject(buffer: DecodeBuffer, struct: Struct): object {
        let map = {};
        for (let field of struct.fieldNames) {
            map[field] = this.readData(buffer);
        }
        return map;
    }
}
